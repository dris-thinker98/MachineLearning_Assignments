# -*- coding: utf-8 -*-
"""ML_A3_Q3

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/177gJ_iacglV4dZGOJoIRCPKOzT9SONQd
"""

from scipy.io import loadmat
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import sys
import os
import joblib    #to save and load models
from random import seed
from random import randrange
from sklearn.metrics import accuracy_score

from google.colab import drive
drive.mount('/content/drive')

D =loadmat('/content/drive/My Drive/ML/Assignment3_datasets/dataset_b.mat')
print(D)

D

data=D['samples']
df=pd.DataFrame(data)
labels=D['labels'].reshape(-1)
df['labels']=labels
print(df)

"""# **Answer to Q3(a)**"""

x=np.array(df[0])
y=np.array(df[1])
z=np.array(df['labels'])

classes=list(df['labels'].unique())
classes.sort()
print(classes)
classes= [str(i) for i in classes]
print(classes)

plt.figure(figsize=(10,8))
sc_plot=plt.scatter(x,y,c=z)
plt.title("Scatter plot on dataset_b.mat")
plt.xlabel("X")
plt.ylabel("Y")
plt.legend(handles=sc_plot.legend_elements()[0],labels=classes)
plt.show()

"""# **Answer to Q3(b)**"""

def nfold_split(data,num): #Here num is the number of splits to be done for the data
  chunk = list()
  dataset = data.values.tolist()
  fold_size = int(len(data)/num)
  for i in range(num):
    fold = list()
    while len(fold) < fold_size:
      index = randrange(len(dataset))
      fold.append(dataset.pop(index))
    chunk.append(fold)
  return chunk

location = "/content/drive/My Drive/ML"
sys.path.append(os.path.abspath(location))
from SVM import SVM_RBF

svm = SVM_RBF(1.0,0.1)
joblib_file = "joblib_svmrbf_model.pkl"  
joblib.dump(svm, joblib_file)

seed(1)
cval = [0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]
gval = [0.1,0.2,0.4,0.6,0.8,1.0,2.0,3.0]
chunks = nfold_split(df, 5)
acc = []
#acc_df1_test = pd.DataFrame()
acc_ovr = pd.DataFrame()
sample = []
for a in range(5):
    df_train = pd.DataFrame()
    for b in range(5):
        if (b==a):
          df_test = pd.DataFrame(chunks[b])
        else:
          #train.append(chunks[j])
          data1 = pd.DataFrame()
          data1 = pd.DataFrame(chunks[b])
          df_train = df_train.append(data1, ignore_index=True)
    #acc_ovr1 = pd.DataFrame()
    acc_df1_test = pd.DataFrame()
    for c in cval:
        #acc_ovr1 = pd.DataFrame()
        for g in gval:
            acc_sk = []
            #acc_df1_test = pd.DataFrame()
            for i in np.sort(df_train[2].unique()):  
                j = int(i)                                                #for df_train
                newdf = pd.DataFrame.reset_index(df_train)
                del newdf['index']
                X = newdf.iloc[:,0:2]
                train = X
                y = np.array(newdf.iloc[:,2:]).reshape(-1)
                for k in range(len(y)):
                    if y[k] == j:
                         y[k] = 1
                    else:
                        y[k] = 0
                #X = newdf.iloc[:,:2]
                y = pd.DataFrame(y)
                train[2] = y
                newdf1 = pd.DataFrame.reset_index(df_test)
                del newdf1['index']
                X = newdf1.iloc[:,0:2]
                test = X
                y = np.array(newdf1.iloc[:,2:]).reshape(-1)
                for k in range(len(y)):
                    if y[k] == j:
                        y[k] = 1
                    else:
                        y[k] = 0
                X = newdf.iloc[:,:2]
                y = pd.DataFrame(y)
                test[2] = y
                X_train = train.iloc[:,0:2]
                y_train = train.iloc[:,2:]                                 #for df_test
                X_test = test.iloc[:,0:2]
                y_test = test.iloc[:,2:]
                svm = SVM_RBF(c,g)
                svm.fit(X_train, np.array(y_train).reshape(-1))
                predicted = svm.predict(X_test)
                y_pred = []
                for v in range(len(predicted)):
                    if predicted[v]>0:
                        y_pred.append(1)
                    else:
                        y_pred.append(0)
                y_pred = np.array(y_pred).reshape(-1)
                y_test = np.array(y_test).reshape(-1)
                accuracy = accuracy_score(y_test, y_pred) * 100
                acc_sk.append([a,c,g,j,accuracy])
                temp = pd.DataFrame()
                temp = temp.append(acc_sk) 
            acc_df1_test = acc_df1_test.append(temp,ignore_index=True)
        #acc_ovr1 = acc_ovr1.append(acc_df1_test,ignore_index=True)
    acc_ovr = acc_ovr.append(acc_df1_test,ignore_index=True)

#along with class wise accuracies
acc_ovr.rename(columns = {0:'Fold No.',
                         1:'C',
                         2:'Gamma',
                         3:'Class',
                         4:'Accuracy'}, inplace = True) 
acc_ovr                                                   ##5*10*8*3 = 1200 values to compare and find optimum

a = [0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]    #values of C
b = [0.1,0.2,0.4,0.6,0.8,1.0,2.0,3.0]          #valus of Gamma
C_mean = []
for i in a:
  acc_mean = acc_ovr.loc[acc_ovr['C']==i]['Accuracy'].sum()
  C_mean.append([i,acc_mean/120])
G_mean = []
for j in b:
  acc_mean = acc_ovr.loc[acc_ovr['Gamma']==i]['Accuracy'].sum()
  G_mean.append([j,acc_mean/150])

C_mean                  #mean accuracies for all C values; here we see C = 0.9 has an optimal value (mean accuracy = 91.67458333333335)

G_mean                  #all mean accuracies are the same therefore can take any. Let us take optimal value of G as 0.1

"""# **Answer to Q3(c)**

Using OVO in SVM with RBF Kernel
"""

seed(1)
cval = [0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]
gval = [0.1,0.2,0.4,0.6,0.8,1.0,2.0,3.0]
pairs = [[0,1],[1,2],[2,0]]              # number of OVO class pairs = N(N-1)/2 = 3(3-1)/2 = 3
chunks = nfold_split(df, 5)
acc = []
#acc_df1_test = pd.DataFrame()
acc_ovr2 = pd.DataFrame()
sample = []
for a in range(5):
    df_train = pd.DataFrame()
    for b in range(5):
        if (b==a):
          df_test = pd.DataFrame(chunks[b])
        else:
          #train.append(chunks[j])
          data1 = pd.DataFrame()
          data1 = pd.DataFrame(chunks[b])
          df_train = df_train.append(data1, ignore_index=True)
    #acc_ovr1 = pd.DataFrame()
    acc_df1_test = pd.DataFrame()
    for c in cval:
        #acc_ovr1 = pd.DataFrame()
        for g in gval:
            acc_sk = []
            #acc_df1_test = pd.DataFrame()
            for [i,j] in pairs:                                                   #for df_train
                newdf = df_train[(df_train[2]==i) | (df_train[2]==j)]
                newdf = pd.DataFrame.reset_index(newdf)
                del newdf['index']
                X = newdf.iloc[:,0:2]
                train = X
                y = np.array(newdf.iloc[:,2:]).reshape(-1)
                for k in range(len(y)):
                    if y[k] == i:
                        y[k] = 1
                    else:
                        y[k] = 0
                #X = newdf.iloc[:,:2]
                y = pd.DataFrame(y)
                train[2] = y
                newdf1 = pd.DataFrame.reset_index(df_test)
                del newdf1['index']
                X = newdf1.iloc[:,0:2]
                test = X
                y = np.array(newdf1.iloc[:,2:]).reshape(-1)
                for k in range(len(y)):
                    if y[k] == j:
                        y[k] = 1
                    else:
                        y[k] = 0
                X = newdf.iloc[:,:2]
                y = pd.DataFrame(y)
                test[2] = y
                X_train = train.iloc[:,0:2]
                y_train = train.iloc[:,2:]                                 #for df_test
                X_test = test.iloc[:,0:2]
                y_test = test.iloc[:,2:]
                svm = SVM_RBF(c,g)
                svm.fit(X_train, np.array(y_train).reshape(-1))
                predicted = svm.predict(X_test)
                y_pred = []
                for v in range(len(predicted)):
                    if predicted[v]>0:
                        y_pred.append(0)
                    else:
                        y_pred.append(1)
                y_pred = np.array(y_pred).reshape(-1)
                y_test = np.array(y_test).reshape(-1)
                accuracy = accuracy_score(y_test, y_pred) * 100
                acc_sk.append([a,c,g,i,j,accuracy])
                temp = pd.DataFrame()
                temp = temp.append(acc_sk) 
            acc_df1_test = acc_df1_test.append(temp,ignore_index=True)
        #acc_ovr1 = acc_ovr1.append(acc_df1_test,ignore_index=True)
    acc_ovr2 = acc_ovr2.append(acc_df1_test,ignore_index=True)

#along with class wise accuracies
acc_ovr2.rename(columns = {0:'Fold No.',
                         1:'C',
                         2:'Gamma',
                         3:'Class i',
                         4:'Class j',
                         5:'Accuracy'}, inplace = True) 
acc_ovr2

a = [0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]    #values of C
b = [0.1,0.2,0.4,0.6,0.8,1.0,2.0,3.0]          #valus of Gamma
C_mean2 = []
for i in a:
  acc_mean = acc_ovr2.loc[acc_ovr2['C']==i]['Accuracy'].sum()
  C_mean2.append([i,acc_mean/120])
G_mean2 = []
for j in b:
  acc_mean = acc_ovr2.loc[acc_ovr2['Gamma']==i]['Accuracy'].sum()
  G_mean2.append([j,acc_mean/150])

C_mean2                                            #mean accuracies for all C values; here we see C = 0.1 has an optimal value (mean accuracy = 74.62333333333332)

G_mean2                                            ##all mean accuracies are the same therefore can take any. Let us take optimal value of G as 0.1

"""# **Answer to Q3(d)**"""

from sklearn.svm import SVC

"""Scikit-Learn SVM with RBF Kernel using OVR"""

cls = SVC(C=0.9, gamma=0.1,kernel='rbf',decision_function_shape='ovr')
joblib_file = "joblib_sklearnSVM_OVR_Model.pkl"  
joblib.dump(cls, joblib_file)

seed(1)
chunks = nfold_split(df, 5)
acc = []
acc_df1_test3 = pd.DataFrame()
sample = []
for a in range(5):
    df_train = pd.DataFrame()
    for b in range(5):
        if (b==a):
          df_test = pd.DataFrame(chunks[b])
        else:
          #train.append(chunks[j])
          data1 = pd.DataFrame()
          data1 = pd.DataFrame(chunks[b])
          df_train = df_train.append(data1, ignore_index=True)
    X_train = df_train.iloc[:,0:2]
    y_train = df_train.iloc[:,2:]                                 #for df_test
    y_train = np.array(y_train).reshape(-1)
    X_test = df_test.iloc[:,0:2]
    y_test = df_test.iloc[:,2:]
    cls.fit(X_train, y_train)
    y_pred = cls.predict(X_test)
    y_test = np.array(y_test).reshape(-1)
    accuracy = accuracy_score(y_test, y_pred) * 100
    acc.append([a,accuracy])
    temp = pd.DataFrame()
    temp = temp.append(acc) 
#acc_df1_test3 = acc_df1_test.append(temp,ignore_index=True)

temp.rename(columns = {0:'Fold No.',1:'Accuracy'}, inplace = True) 
temp

"""Scikit-Learn SVM with RBF Kernel using OVO"""

cls2 = SVC(C=0.1, gamma=0.1,kernel='rbf',decision_function_shape='ovo')
joblib_file = "joblib_sklearnSVM_OVO_Model.pkl"  
joblib.dump(cls2, joblib_file)

seed(1)
chunks = nfold_split(df, 5)
acc1 = []
for a in range(5):
    df_train = pd.DataFrame()
    for b in range(5):
        if (b==a):
          df_test = pd.DataFrame(chunks[b])
        else:
          #train.append(chunks[j])
          data1 = pd.DataFrame()
          data1 = pd.DataFrame(chunks[b])
          df_train = df_train.append(data1, ignore_index=True)
    X_train = df_train.iloc[:,0:2]
    y_train = df_train.iloc[:,2:]                                 #for df_test
    y_train = np.array(y_train).reshape(-1)
    X_test = df_test.iloc[:,0:2]
    y_test = df_test.iloc[:,2:]
    cls2.fit(X_train, y_train)
    y_pred = cls2.predict(X_test)
    y_test = np.array(y_test).reshape(-1)
    accuracy = accuracy_score(y_test, y_pred) * 100
    acc1.append([a,accuracy])
    temp1 = pd.DataFrame()
    temp1 = temp1.append(acc1)

temp1.rename(columns = {0:'Fold No.',1:'Accuracy'}, inplace = True) 
temp1